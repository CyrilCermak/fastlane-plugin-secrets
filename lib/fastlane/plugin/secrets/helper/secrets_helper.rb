require 'fastlane_core/ui/ui'

module Fastlane
  UI = FastlaneCore::UI unless Fastlane.const_defined?("UI")

  module Helper
    class SecretsHelper

      def self.inject_secrets(file)
        # replace /* SECRETS */ with UInt8 byte data

        # TODO:
        #         private let keys: [[UInt8]] = [
        #              "gnbkjfghrbjn".utf8.map{UInt8($0)},
        #              "token".utf8.map{UInt8($0)}, [10, 23, 79, 24, 15, 5, 21, 13, 6, 79, 30, 1, 12, 11, 12]
        #         ]

      end

      def self.generate_template(file)
        open(file, 'w') do |f|
          f << "//\n"
          f << "//  Autogenerated file by Fastlane-Plugin-Secret\n"
          f << "//\n"
          f << "\n"
          f << "import Foundation\n"
          f << "\n"
          f << "class Secrets {\n"
          f << "    static let standard = Secrets()\n"
          f << "    private let keys: [[UInt8]] = [[/* SECRETS */]]\n"
          f << "\n"
          f << "    private init() {}\n"
          f << "\n"
          f << "    func string(forKey key: String) -> String? {\n"
          f << "        guard let index = keys.index(where: { String(data: Data(bytes:$0), encoding: .utf8) == key }),\n"
          f << "              let bytes = decrypt(keys[index + 1]) else { return nil }\n"
          f << "        return String(data: Data(bytes: bytes), encoding: .utf8)\n"
          f << "    }\n"
          f << "\n"
          f << "    public func decrypt(_ input: [UInt8]) -> [UInt8]? {\n"
          f << "        let key = keys[0]\n" # the master key is stored at index 0
          f << "        guard !key.isEmpty else { return nil }\n"
          f << "        var output = [UInt8]()\n"
          f << "        for byte in input.enumerated() {\n"
          f << "            output.append(byte.element ^ key[byte.offset % key.count])\n"
          f << "        }\n"
          f << "        return output\n"
          f << "    }\n"
          f << "}\n"
        end
      end

      def self.xor_chiper(key, string)
        key_chars = key.chars
        result = ""
        codepoints = string.each_codepoint.to_a
        codepoints.each_index do |i|
          result += (codepoints[i] ^ key_chars[i % key_chars.size].ord).chr
        end
        result
      end

    end
  end
end
